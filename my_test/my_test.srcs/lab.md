# Пояснения к файлам:

test.sv и tb_test.sv - файлы в неактивном поле для Лаб№1,
top.sv и tb_led_blink - файлы для Лаб№2.

# Лаб№2 Ответы на доп. вопрос

## 1.6 Поясните следующую строку кода:

    constant COUNTER_WIDTH : positive : positive (ceil(log2(real(COUNTER_PERIOD + 1)))); 

В данной строке задаётся константа  COUNTER_WIDTH, которая будет иметь следующее значение: переменная COUNTER_PERIOD приводится к типу real. Real - вещественное число в диапазоне от -(10^308) до +(10^308). Затем это число заносится в логарифм по основания 2. После этих операций исппользуется функция ceil, которая округляет число в большую сторону. Затем, с помощью positive, значение приводится к подтипу integer - positive. На выходе получается целое положительное число.

## 1.8 Как вы думаете, почему в приборах используют именно мигающие индикаторы, а не постоянно светящиеся?

Мигающие светодиоды потребляют меньше энергии, что может быть критичным на приборах, работающих от аккумулятора. Также, они больше привлекают внимание пользователя и  могут показать ему, корректно ли работает прибор.

## 2.1 В чем отличия синтезируемого и несинтезируемого подмножеств языков описания?

Синтезируемые подмножества можно преобразовать в bitstream и загрузить на плату, в то время как  несинтезируемые используется в основном для симуляции. Также, несинтезируемые подмножества не могут быть преобразованы в аппаратную схему с цифровыми блоками.

## 3.1 Из каких элементов состоит синтезированная схема?

Триггеры, лог. элементы (AND, OR, NOT, XOR), LUT'ы, регистры, буферы.

## 3.2 Какие еще элементы могут составлять схему?

Мультиплексоры, демультиплексоры.

## 3.3 Как изменится схема, если отключить сигнал i_rst от входа микросхемы?

Вход i_rst будет висеть в воздухе отдельно от всей схемы и не будет влиять на выполнение программы.

## 3.4 Почему в симуляторе (в blink_led_tb) можно использовать тип real, а в описании модуля (blink_led) этот тип можно использовать только для вычисления констант?

Потому что тип real не является синтезируемым, и он должен быть преобразован в другой тип данных. blink_led_tb используется для симуляции, поэтому несинтезируемый тип данных может использоваться.

## 3.5 Можно ли разделить значение счетчика counter_value на какое-нибудь число? Будет ли такое описание синтезировано? Будет ли синтезировано умножение counter_value на число?

Разделить можно, синтез происходить будет. Также и с умножением (выяснено эмпирическим путём).

## 4.1 Как располагаются элементы дизайна на кристалле микросхемы?

Как можно ближе для эффективного распределения энергоресурсов и уменьшения задержки.

## 4.2 На что влияет параметр тактовой частоты в файле ограничений timings.xdc? Что будет, если указать период ТЧ 1 нс?

Параметр влияет на частоту тактирования. При текущих параметрах частота будет 50кГц. При изменении периода на 1 нс частота увеличится до 1 ГГц.

## 4.3 Что определяет параметр IOSTANDARD в pinouts.xdc?

Параметр IOSTANDARD определяет стандарт интерфейса для каждого вывода компонента(LVCMOS, SSTL, HSTL, LVDS).

## 5.1 Что произойдет с платой и прошивкой, если выключить и включить питание? Как можно объяснить результат?

Прошивка осхраняется в энергозависимой памяти. Соответственно, при выключении и включении она будет сброшена.

## 5.2 Что такое JTAG? Зачем он необходим?

JTAG - это группа разработчиков стандарта IEEE 1149. С помощью JTAG можно проводить тестирование и отладку устройств, используя набор контактов на печатной плате.

## 6.1 Отличия always_ff и always_comb?

always_ff реализует триггер, always_comb реализует комбинационную схему.

## 6.2 В чем разница между разными видами присвоения: а = с и a <= c?

а = с - Блокирующее присваивание, используются для моделирования комбинационной логики и при использовании always_comb

a <= c - Неблокирующее присваивание, используется для моделирования последовательной логики с оператором always

## 6.3 Поясните, за что отвечает фрагмент кода:

### а) reg [COUNTER_WIDTH -1 : 0] counter_value = '0;

Создаётся регистр counter_value в диапозоне COUNTER_WIDTH -1 до 0, где каждый элемент будет равен 0.

### б) always_ff @(posedge i_clk) begin

По переднему фронту частоты i_clk реализуется триггер.

### в) assign o_led = {0:(~i_rstn | led_on), default:(~i_rstn | ~led_on)};

o_led[0] = ~i_rstn | led_on,
o_led[1...] = ~i_rstn | ~led_on.

### г) 

### localparam COUNTER_WIDTH int($ceil($clog2(COUNTER_PERIOD +1)));

Объявляется локальная константа типа int COUNTER_WIDTH, которая определяется из округления в большую сторону логарифма по основанию 2 (COUNTER_PERIOD + 1).

### д) always #(T_CLK/2) i_clk = ~i_clk;

Каждый полупериод T_CLK инвертируется сигнал i_clk.

### е)

### initial begin

### i_rstn = 1'b1;

### #10e3 i_rstn = 1'b0;

### #(20*T_CLK) i_rstn = 1'b1;

### end

initial - инициализация процесса - аналог always в симуляции. Сперва i_rstn присваевается значение 1. Затем, реализуется задержка в 10^3 наносек, после чего i_rstn становится равным 0. Через 20*T_CLK наносек i_rstn вновь становится равным 1.

## 6.4 Отличия двух деклараций сигналов:

### reg [COUNTER_WIDTH -1 : 0] counter_value = '0;

### wire [COUNTER_WIDTH -1 : 0] counter_value = '0;

В первом случае создаётся регистр, во втором - провод. Основное отличие заключается в том, что wire не может хранить информацию, а reg хранит до того момента, пока она не будет переназначена.

## 7.1 Отличия запакованных типов от распакованных:

Запакованные типы хранятся непрерывно в памяти, что обеспечивает более быстрый доступ к данным, будет представлен как непрерывный набор битов;

Распакованные типы хранятся без непрерывного размещения в памяти, могут быть массивами фиксированного и динамического размера, также и очередями;

